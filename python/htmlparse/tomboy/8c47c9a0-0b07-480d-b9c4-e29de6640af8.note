<?xml version="1.0" encoding="utf-8"?>
<note version="0.3" xmlns:link="http://beatniksoftware.com/tomboy/link" xmlns:size="http://beatniksoftware.com/tomboy/size" xmlns="http://beatniksoftware.com/tomboy">
  <title>Java notes - Extensive</title>
  <text xml:space="preserve"><note-content version="0.1">Java notes - Extensive

An interface defines a protocol of communication between two objects.

An interface declaration contains signatures, but no implementations, for a set of methods, and might also contain constant definitions.

All methods declared in an interface are implicitly public and abstract, so the public modifier can be omitted.

All constant values defined in an interface are implicitly public, static, and final. Once again, these modifiers can be omitted.

Pooling of objects applies only to String,Integer.valueOf() objects that has not been initialized;

Primitive <link:internal>types</link:internal> are not objects - they are not polymorphic and cannot exhibit any object behaviour. 

Object equivalents behave polymorphically (the numeric ones form an inheritance hierarchy derived from java.lang.Number)

Primitive <link:internal>types</link:internal> are passed by value into methods. Object equivalents are passed by reference.

Primitive <link:internal>types</link:internal> are not reference counted or garbage collected. Object equivalents are.

Primitive <link:internal>types</link:internal> are mutable. Their object equivalent (wrapper) classes are all immutable.

String Buffers doesnot override the equals() method and hence by default they check the equality of there references, and does not do the String comparison.

Object is created out on the garbage-collectible heap

Threads:
static sleep(milli,nano)
static sleep(milli)
throws InterruptedException, if disturbed by other Thread
boolean Thread.interrupted()
When a thread checks for an interrupt by invoking the static method Thread.interrupted, interrupt status is cleared. 

The non-static Thread.isInterrupted, which is used by one thread to query the interrupt status of <link:internal>another</link:internal>, does not change the interrupt status flag.

By convention, any method that exits by throwing an InterruptedException clears interrupt status when it does so.

public void t.join();
Like sleep, join responds to an interrupt by exiting with an InterruptedException.

Thread interference- Interleaving problem.

<link:internal>Memory</link:internal> Consistency errors- value of the <link:internal>memory</link:internal> location issue.

Note that constructors cannot be synchronized  using the synchronized keyword with a constructor is a syntax error.

Synchronizing constructors doesn't make sense, because only the thread that creates an object should have access to it while it is being constructed.

Every object has an intrinsic lock associated with it.

The lock release occurs even if the return was caused by an uncaught exception.

Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:

A thread can acquire a lock that it already owns

Volatile variables share the visibility features of synchronized, but none of the atomicity features.

Collection&lt;E&gt;.remove(Object o) // takes Object not E be careful.

Also Collection.Contains.Map.get(Object o)

URL's equal method gives true if
same host-IP address
port number
file, fragments
do not use URl as a Set element of Map key
equals and hascode arent well defined
they do not obey their general contracts

The compiler not only translates Unicode escapes into the characters they represent before
it parses a program into tokens, but it does so before discarding comments and white space

When System.exit is called, the virtual machine performs two cleanup tasks
before shutting down. 
First, it executes all shutdown hooks that have been registered
with Runtime.addShutdownHook. This is useful to release resources external
to the VM. Use shutdown hooks for behavior that must occur before the
VM exits.

All methods declared within an interface are implicitly public, a weaker access level can not be declared.

The access specifier for an overriding method can allow more, but not <link:internal>less</link:internal>, access than the overridden method.

You will get a compile-time error if you attempt to change an instance method in the superclass to a class method in the subclass, and vice versa.

No matter where they declared, static variables will be intitialized before non-static variables.

Java allows you to use ~ operator for integer type variables. The simple way to calculate is ~i = (- i) - 1.

By default objects will be initialized to null and primitives to their corresponding default vaulues. The same rule applies to array of objects and primitves.

Static final transient int maxElements = 100; // is correct

Once array is created then it is not possible to change the length of the array.

You can't add primitives to Vector.

The order of floating/double values is -Infinity --&gt; Negative Numbers/Fractions --&gt; -0.0 --&gt; +0.0 --&gt; Positive Numbers/Fractions --&gt; Infinity.

java.util.ConcurrentModificationException -- If vector is modified *after* the creation of the iterator.

Multiple threads with the same name can execute simultaneously.

final strictfp public static void main(String args[]){}

The JLS states that the run function must be public, static, return void and take as parameters an array of strings. 
The above defined function meets the requirements.

There is no Byte constructor that takes as a parameter a Byte. 

This is true for all std wrapper classes: Boolean, Byte, Character, Short, Integer, Long, Float, Double.

If you try to catch a checked exception (like IOException) from an empty try block the code will not compile. 
The compiler will issue the following error:
exception java.io.IOException is never thrown in body of corresponding try statement.

Transient variables are not serialized. 
Local variables are not serialized anyway so it makes no sense to apply this qualifier to a local variable.

It is legal to feed the Float constructor with a string ending in 'f' or 'F'.

The code does not compile. You cannot have in one source file 2 public classes or interfaces or a mix of them.

char A = '\u000A'; Doesnt work, for special characters are processed early in translation <link:internal>process</link:internal>

main can be private in earlier than Java 1.4 version.
In later versions it doesnt work.

The strictfp modifier can be used with <link:internal>top</link:internal>-level classes, nested classes, nested interfaces, and method declarations. 

It can not be used with variables, constructors, or initializer blocks. 
It also cannot be combined with the abstract modifier.

Each .java source file can contain at most one <link:internal>top</link:internal>-level class (or interface) definition that is public. 
If a <link:internal>top</link:internal>-level public class (or interface) definition is present, then the .java source file must share that name exactly (matching case).

NaN is unordered, so the numerical comparison operators &lt;, &lt;=, &gt;, and &gt;= always return false if either or both operands are NaN

A Vector defaults to doubling the size of its array, while the ArrayList increases its array size by 50 percent

Static methods are implicitly final, because overriding is done based on the type of the object, 
and static methods are attached to a class, not an object.

Methods may be overridden to be more public, not more private.

Nested <link:internal>top</link:internal>-level classes, Member classes, Local classes, Anonymous classes

An overriding method can also return a subtype of the type returned by the overridden method. This is called a covariant return type. 

The version of the overridden method that gets invoked is the one in the subclass. 

The version of the hidden method that gets invoked depends on whether it is invoked from the superclass or the subclass.

PKZIP compatible reader such as WinRAR, WinZip, or the Java archiver, jar

Java provides three techniques for creating a one-dimensional array:
use only an initializer, 			int [] test_scores = {1,2,3,4};
use only keyword new, 				int [] test_scores = new int [4];
and use keyword new with an initializer.	int [] test_scores = new int [] { 70, 80, 20, 30 };
                      

// If byte's computed value is greated that 127 in the assignment statement, compiler error

// In a bytes assignment, if a variable comes into picture, then compiler error


After encountering a string, trailing numbers are treated as strings. and evaluated to separated chars in the string.
"amjed"+700+80+6 evaluates amjed700806

Yes, the main method can be declared final, in addition to being public static.

The FileNoFoundException is inherited from the IOException. Exception's subclasses have to be caught first.</note-content></text>
  <last-change-date>2011-02-23T12:18:26.5078720+01:00</last-change-date>
  <last-metadata-change-date>2012-02-02T10:45:00.7027920+01:00</last-metadata-change-date>
  <create-date>2010-11-07T15:38:03.4024670+01:00</create-date>
  <cursor-position>6838</cursor-position>
  <selection-bound-position>6838</selection-bound-position>
  <width>450</width>
  <height>360</height>
  <x>0</x>
  <y>0</y>
  <tags>
    <tag>system:notebook:Java</tag>
  </tags>
  <open-on-startup>False</open-on-startup>
</note>
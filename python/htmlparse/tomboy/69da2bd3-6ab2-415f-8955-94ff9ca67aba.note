<?xml version="1.0" encoding="utf-8"?>
<note version="0.3" xmlns:link="http://beatniksoftware.com/tomboy/link" xmlns:size="http://beatniksoftware.com/tomboy/size" xmlns="http://beatniksoftware.com/tomboy">
  <title>Sed</title>
  <text xml:space="preserve"><note-content version="0.1">Sed


This is a document to exhibit the functionalities of sed
sed is a powerful editor that operates on stream
It is derived from the ed editor of Unix OS

The syntax of sed command is as given below:

<bold><italic>sed option 'address command' filename</italic></bold>

where option can be any of the below:
-n do not print the file contents
-f take the instructions from the file
-<link:internal>Schema and data</link:internal> mulitple expressions

'address command' tuple is called as an instruction
address can be specified in one of the two formats:
1.line numbers ex 1, 1,3, 1,$ 
2.regular expression to match in the line, ex /pattern/

There are a rich number of commands, that adds enormous power to this filter, some of them i could recollect are:
p -print the selected line
q -quit
! -negate
s -substitute
c -copy
d -delete
i -insert
r -replace

<bold>Append to the end of the line 1</bold>:
<italic>sed -<link:internal>Schema and data</link:internal></italic><italic> "1s<link:url>/$/(Answer</link:url></italic><italic> is NO)/" factbook.txt</italic>

<italic>sed -n "/10\{2,4\}\ /p" numbers.no </italic>
<italic>#</italic>match only  100, 1000 and 10000 delimited by space

<italic>sed -n "/1...\ /p" numbers.no </italic>
#match any pattern "1 followed by 3 characters and a space"


Unless the <bold>g  (global) </bold>operator is appended to a substitute command, the substitution operates only on the <bold>first instance</bold> of a pattern match <bold>within each line</bold>.

<bold>To change from .py to .pl</bold>
<link:internal>find</link:internal> . -name *.py | sed  's/\(.*\).py/\1.pl/g'

\( \) matches the occurrence and assigns to \1 in the replacement



<bold>When replacing:</bold>

    \r is newline, \n is a null byte (0x00). 
    \&amp; is ampersand (&amp; is the text that matches the search pattern). 
    \1 inserts the text of the first backreference. \2 inserts the second backreference, and so on. 

You can use other delimiters with substitute:

    :s#<link:url>http://www.example.com/index.<link:internal>html</link:internal></link:url><link:url>#http://example.com/</link:url># </note-content></text>
  <last-change-date>2010-12-05T16:03:15.6101450+01:00</last-change-date>
  <last-metadata-change-date>2012-01-25T11:50:43.7386510+01:00</last-metadata-change-date>
  <create-date>2010-01-02T07:42:55.4143460+01:00</create-date>
  <cursor-position>1717</cursor-position>
  <selection-bound-position>1717</selection-bound-position>
  <width>450</width>
  <height>360</height>
  <x>0</x>
  <y>0</y>
  <tags>
    <tag>system:notebook:Scripts</tag>
  </tags>
  <open-on-startup>False</open-on-startup>
</note>